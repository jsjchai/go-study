## 协程（Goroutine）
### 进程（Process）
> 指计算机中已运行的程序。进程曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，**进程本身不是基本运行单位，而是线程的容器**。程序本身只是指令、数据及其组织形式的描述，**进程才是程序（那些指令和数据）的真正运行实例**。若干进程有可能与同一个程序相关系，且每个进程皆可以同步（循序）或异步（平行）的方式独立运行。现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术（多线程即每一个线程都代表一个进程内的一个独立执行上下文）的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（在不同的CPU上）。
### 线程（Thread）
> 指操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。在Java语言中，线程有6种状态，初始(NEW)->运行(RUNNABLE)->阻塞(BLOCKED)->等待(WAITING)->超时等待(TIMED_WAITING)->终止(TERMINATED)
### 协程（Goroutine）
> 计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道
## 进程与线程的区别
> 进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程。
## 协程与线程的区别
> 协程非常类似于线程。但是协程是协作式多任务的，而线程典型是抢占式多任务的。这意味着协程提供并发性而非并行性。协程超过线程的好处是它们可以用于硬性实时的语境（在协程之间的切换不需要涉及任何系统调用或任何阻塞调用），这里不需要用来守卫关键区块的同步性原语（primitive）比如互斥锁、信号量等，并且不需要来自操作系统的支持。有可能以一种对调用代码透明的方式，使用抢占式调度的线程实现协程，但是会失去某些利益（特别是对硬性实时操作的适合性和相对廉价的相互之间切换）。
**纤程**是协作式多任务的轻量级线程，本质上描述了同协程一样的概念。其区别，如果一定要说有的话，是协程是语言层级的构造，可看作一种形式的控制流，而纤程是系统层级的构造，可看作恰巧没有并行运行的线程。这两个概念谁有优先权是争议性的：纤程可看作为协程的一种实现，也可看作实现协程的基底。
* Golang | Goroutine vs Thread
| GOROUTINE | THREAD |
| ------ | ------ |
| Goroutines由go运行时管理 | 线程由操作系统内核管理 |
| 不依赖于硬件 | 依赖于硬件（cpu核数、内存大小的等） |  
| 由channel作为容易的通信媒介 | 线程通信比较困难 |  
| 由于channel的存在，一个goroutine可以与其他goroutine进行低延迟的通信 | 线程间的通信延迟很大 | 
|Goroutine没有id,没有Thread Local Storage|有唯一线程id，有Thread Local Storage|
|比线程开销低|比GOROUTINE开销高|
|协作式多任务|抢占式多任务|
|有可增长的分段堆栈|无可增长的分段堆栈|
## 参考文档
[golang-goroutine-vs-thread](https://www.geeksforgeeks.org/golang-goroutine-vs-thread/)

[进程wiki](https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B)
